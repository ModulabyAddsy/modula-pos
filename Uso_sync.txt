# Asumimos que este c√≥digo vive en un archivo como 'src/core/modules/ventas_module.py'

import src.core.local_storage as local_storage
from src.core.app_controller import AppController

class ModuloVentas:
    def __init__(self, app_controller: AppController):
        """
        El m√≥dulo recibe una referencia al controlador principal para poder
        llamar a la funci√≥n de sincronizaci√≥n.
        """
        self.app_controller = app_controller

    def cerrar_venta(self, items_vendidos: list, cliente_id: str, total: float, metodo_pago: str):
        """
        Esta es la funci√≥n que se llama desde la UI para finalizar una venta.
        Orquesta todo el proceso de guardado y sincronizaci√≥n.
        """
        print("‚ñ∂Ô∏è  Iniciando proceso para cerrar venta...")

        # 1. Preparamos el diccionario con los datos que se guardar√°n en la tabla 'ventas'.
        #    Aseg√∫rate de que las claves coincidan con las columnas de tu DB.
        datos_nueva_venta = {
            "total_venta": total,
            "metodo_pago": metodo_pago,
            "id_cliente": cliente_id,
            "id_usuario": self.app_controller.usuario_actual['uuid'], # Obtenemos el usuario de la sesi√≥n
            "detalles_venta": self.convertir_items_a_json(items_vendidos) # Ejemplo de un campo JSON
        }

        # --- PASO 1: GUARDAR LA VENTA ---
        try:
            # Usamos nuestra funci√≥n universal. Se guarda localmente y se marca con needs_sync = 1.
            nuevo_uuid = local_storage.guardar_nuevo_registro(
                self.app_controller.id_empresa_addsy,
                self.app_controller.id_sucursal_actual, # Atributo que deber√≠as tener en AppController
                'ventas',
                datos_nueva_venta
            )
            print(f"‚úÖ Venta {nuevo_uuid} guardada localmente. Lista para ser enviada.")

        except Exception as e:
            print(f"üî•üî• ERROR CR√çTICO: No se pudo guardar la venta localmente. {e}")
            # Aqu√≠ deber√≠as mostrar un error grave al usuario. La venta no se guard√≥.
            self.app_controller.show_error("No se pudo registrar la venta. Revisa la conexi√≥n.")
            return # Detenemos el flujo

        # --- PASO 2 Y 3: ENVIAR Y SINCRONIZAR ---
        # Con una sola l√≠nea, le pedimos al controlador que inicie la sincronizaci√≥n
        # en segundo plano. La UI nunca se congelar√°.
        print("üîÑ Disparando la sincronizaci√≥n en segundo plano...")
        self.app_controller.sincronizar_ahora(
            on_finished_callback=lambda status: self.on_venta_sincronizada(status, nuevo_uuid)
        )

        print("‚úÖ Proceso de venta finalizado en la UI. La sincronizaci√≥n se completar√° por detr√°s.")

    def on_venta_sincronizada(self, status: str, uuid_venta: str):
        """
        Este es el 'callback' que se ejecuta cuando el SyncWorker termina.
        Es opcional, pero muy √∫til para dar feedback al usuario.
        """
        if status == 'success':
            print(f"‚òÅÔ∏è  ¬°√âxito! La venta {uuid_venta} ya est√° en la nube.")
            # Aqu√≠ podr√≠as cambiar un icono en la UI de "pendiente" a "sincronizado".
        else:
            print(f"‚ö†Ô∏è  La sincronizaci√≥n de la venta {uuid_venta} fall√≥. Se reintentar√° autom√°ticamente m√°s tarde.")
            
    def convertir_items_a_json(self, items: list) -> str:
        # Funci√≥n de ayuda para convertir la lista de productos a un string JSON
        import json
        return json.dumps(items)
